from odoo import models, fields, api, _
from odoo.exceptions import UserError
from odoo.addons.stock.models.stock_move import PROCUREMENT_PRIORITIES


MEASURES = ['length', 'width', 'height']


class CuttingOrder(models.Model):
    _name = 'cutting.order'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _description = 'Cutting Order'

    @api.model
    def create(self, vals):
        n_fixed = sum([1 if vals.get('fixed_' + m) else 0 for m in MEASURES])
        if n_fixed != 2:
            raise UserError(_('You have to choose 2 of Fixed Length, Fixed Width, and Fixed Height!'))

        if vals.get('name', _('New')) == _('New'):
            vals['name'] = self.env['ir.sequence'].next_by_code(
                'cutting.order', sequence_date=None
            ) or _('New')
        return super(CuttingOrder, self).create(vals)

    def write(self, vals):
        n_fixed = sum([1 if vals.get('fixed_' + m, self['fixed_' + m]) else 0 for m in MEASURES])
        if n_fixed != 2:
            raise UserError(_('You have to choose 2 of Fixed Length, Fixed Width, and Fixed Height!'))
        return super(CuttingOrder, self).write(vals)

    @api.model
    def _default_branch_id(self):
        default_branch_id = self.env.context.get('default_branch_id', False)
        if default_branch_id:
            return default_branch_id
        user_branches = self.env.user.branch_id | self.env.user.branch_ids
        if user_branches:
            return user_branches.filtered(lambda b: b.company_id == self.env.company)[0].id
        return False

    @api.model
    def _default_approval_matrix(self, company=None, branch=None):
        if not company:
            company = self.env.company
        if not company.is_cutting_order:
            return False

        default = self.env.context.get('default_approval_matrix_id', False)
        if default:
            return default

        if not branch:
            branch = self.env.user.branch_id
        return self.env['mrp.approval.matrix'].search([
            ('company_id', '=', company.id),
            ('branch_id', '=', branch.id),
            ('matrix_type', '=', 'co')
        ], limit=1).id

    @api.model
    def _default_analytic_tag_ids(self, force_company=False, force_branch=False):
        company_id = self.env['res.company'].browse(force_company or self.env.context.get('default_company_id', self.env.company.id))
        branch_id = self.env['res.branch'].browse(force_branch or self._default_branch_id())
        if company_id and branch_id:
            analytic_priority_ids = self.env['analytic.priority'].search([], order='priority')
            for analytic_priority in analytic_priority_ids:
                if analytic_priority.object_id == 'user' and self.env.user.analytic_tag_ids:
                    analytic_tags_ids = self.env['account.analytic.tag'].search([
                        ('id', 'in', self.env.user.analytic_tag_ids.ids),
                        ('company_id', '=', company_id.id)
                    ])
                    return [(6, 0, analytic_tags_ids.ids)]
                elif analytic_priority.object_id == 'branch' and self.env.user.branch_id.analytic_tag_ids:
                    analytic_tags_ids = self.env['account.analytic.tag'].search([
                        ('id', 'in', branch_id.analytic_tag_ids.ids),
                        ('company_id', '=', company_id.id)
                    ])
                    self.analytic_group_ids = analytic_tags_ids
                    return [(6, 0, analytic_tags_ids.ids)]
        return False

    @api.depends('product_id')
    def _compute_allowed_lots(self):
        lot = self.env['stock.production.lot']
        for record in self:
            domain = [('product_id', '=', record.product_id.id)]
            lot_ids = lot.search(domain)
            allowed_lot_ids = []
            for lot_id in lot_ids:
                quants = lot_id.quant_ids.filtered(
                    lambda q: q.location_id.usage == 'internal' or
                              (q.location_id.usage == 'transit' and q.location_id.company_id)
                )
                if sum(quants.mapped('quantity')):
                    allowed_lot_ids.append(lot_id.id)
            record.allowed_lot_ids = [(6, 0, allowed_lot_ids)]

    @api.depends('product_id', 'product_id.tracking', 'product_id.is_in_autogenerate', 'product_id.is_sn_autogenerate')
    def _compute_auto_generated(self):
        lot_conf = self.env['ir.config_parameter'].get_param('autogenerated.based.methods')
        for record in self:
            record.is_autogenerated = False
            if lot_conf != 'autogenerated_based_product':
                continue
            product_id = record.product_id
            tracking = product_id.tracking

            is_auto_lot = (product_id.is_in_autogenerate and tracking == 'lot')
            is_auto_serial = (product_id.is_sn_autogenerate and tracking == 'serial')
            record.is_autogenerated = is_auto_lot or is_auto_serial

    @api.depends('approval_matrix_id', 'is_matrix_on')
    def _compute_approval_matrix_lines(self):
        for record in self:
            lines = []
            if record.is_matrix_on:
                for line in record.approval_matrix_id.line_ids:
                    lines += [(0, 0, {
                        'co_id': record.id,
                        'line_id': line.id,
                        'sequence': line.sequence,
                        'minimum_approver': line.minimum_approver,
                        'approver_ids': [(6, 0, line.approver_ids.ids)]
                    })]
            record.approval_matrix_line_ids = lines

    @api.depends('approval_matrix_line_ids', 'approval_matrix_line_ids.need_action_ids', 'is_matrix_on')
    def _compute_user_is_approver(self):
        user = self.env.user
        for record in self:
            need_action_ids = record.approval_matrix_line_ids.mapped('need_action_ids')
            record.user_is_approver = user in need_action_ids and record.is_matrix_on

    priority = fields.Selection(PROCUREMENT_PRIORITIES, string='Priority', default='0', index=True)
    name = fields.Char(string='Cutting Order', required=True, copy=False, readonly=True, default=lambda self: _('New'), tracking=True)
    
    product_id = fields.Many2one('product.product', string='Product', required=True, readonly=True, states={'draft': [('readonly', False)]}, domain="[('branch_id', '=', branch_id), ('is_cutting_product', '=', True), '|', ('company_id', '=', company_id), ('company_id', '=', False)]", tracking=True)
    allowed_lot_ids = fields.Many2many('stock.production.lot', compute=_compute_allowed_lots)
    product_uom_id = fields.Many2one('uom.uom', string='Unit of Measure', related='product_id.uom_id')
    cutting_uom_id = fields.Many2one('uom.uom', string='Cutting Unit of Measure', related='product_id.cutting_unit_measure')

    workcenter_id = fields.Many2one('mrp.workcenter', string='Work Center', required=True, readonly=True, states={'draft': [('readonly', False)]}, domain="[('branch_id', '=', branch_id), '|', ('company_id', '=', company_id), ('company_id', '=', False)]", tracking=True)
    
    date_planned_start = fields.Datetime(string='Planned Start Date', required=True, default=fields.Datetime.now, readonly=True, states={'draft': [('readonly', False)]}, tracking=True)
    date_planned_finished = fields.Datetime(string='Planned Finish Date', required=True, default=fields.Datetime.now, readonly=True, states={'draft': [('readonly', False)]}, tracking=True)
    date_start = fields.Datetime(string='Actual Start Date', readonly=True)
    date_finished = fields.Datetime(string='Actual Finish Date', readonly=True)
    
    fixed_length = fields.Boolean(string='Fixed Length', tracking=True)
    fixed_width = fields.Boolean(string='Fixed Width', tracking=True)
    fixed_height = fields.Boolean(string='Fixed Height', tracking=True)
    
    analytic_group_ids = fields.Many2many('account.analytic.tag', domain="[('company_id', '=', company_id)]", string="Analytic Group", readonly=True, states={'draft': [('readonly', False)]}, default=_default_analytic_tag_ids, tracking=True)
    
    company_id = fields.Many2one('res.company', string='Company', default=lambda self: self.env.user.company_id, readonly=True, required=True)
    is_branch_required = fields.Boolean(related='company_id.show_branch')
    branch_id = fields.Many2one('res.branch', string='Branch', default=lambda self: self.env.branch.id if len(self.env.branches) == 1 else False, domain=lambda self: [('id', 'in', self.env.branches.ids)], readonly=True, states={'draft': [('readonly', False)]}, required=True, tracking=True)
    create_uid = fields.Many2one('res.users', string='Created By', default=lambda self: self.env.user, tracking=True)
    
    approval_matrix_id = fields.Many2one(
        comodel_name='mrp.approval.matrix', 
        domain="""[
            ('matrix_type', '=', 'co'),
            ('branch_id', '=', branch_id),
            ('company_id', '=', company_id)
        ]""",
        string='Approval Matrix', 
        default=_default_approval_matrix)

    approval_matrix_line_ids = fields.One2many(
        comodel_name='mrp.approval.matrix.entry',
        inverse_name='co_id',
        string='Approval Matrix Lines',
        compute=_compute_approval_matrix_lines,
        store=True)

    is_matrix_on = fields.Boolean(
        string='Is Matrix On', 
        related='company_id.is_cutting_plan')

    user_is_approver = fields.Boolean(compute=_compute_user_is_approver)

    state = fields.Selection([
        ('draft', 'Draft'),
        ('confirm', 'Confirmed'),
        ('to_be_approved', 'To be Approved'),
        ('approved', 'Approved'),
        ('rejected', 'Rejected'),
        ('progress', 'In Progress'),
        ('done', 'Done'),
        ('cancel', 'Cancelled')
    ], string='Status', default='draft', tracking=True)

    lot_ids = fields.One2many('cutting.order.line', 'cutting_lot_id', string='Production Lots', readonly=True, states={'draft': [('readonly', False)]})
    line_ids = fields.One2many('cutting.order.line', 'cutting_line_id', string='Cutting Lines')
    leftover_ids = fields.One2many('cutting.order.line', 'cutting_leftover_id', string='Leftovers')
    byproduct_ids = fields.One2many('cutting.order.byproduct', 'cutting_id', string='By-Products')

    location_id = fields.Many2one('stock.location', string='Cutting Location', required=True, readonly=True, states={'draft': [('readonly', False)]})
    finished_location_id = fields.Many2one('stock.location', string='Finished Location', required=True, readonly=True, states={'draft': [('readonly', False)]})
    byproduct_location_id = fields.Many2one('stock.location', string='By-Product Location', required=True, readonly=True, states={'draft': [('readonly', False)]})

    is_autogenerated = fields.Boolean(compute=_compute_auto_generated)
    cutting_order = fields.Boolean('Is Cutting Order')
    
    source_document = fields.Char('Source Document')

    # for one2many purpose (see cutting.plan)
    cutting_plan_id = fields.Many2one(
        comodel_name='cutting.plan', 
        string='Cutting Plan')

    # technical fields
    state_1 = fields.Selection(related='state', tracking=False, string='State 1')
    state_2 = fields.Selection(related='state', tracking=False, string='State 2')
    state_3 = fields.Selection(related='state', tracking=False, string='State 3')
    req_approval_datetime = fields.Datetime(string='Request Approval Date')

    @api.onchange('company_id', 'branch_id')
    def onchange_company_branch(self):
        self.approval_matrix_id = self._default_approval_matrix(company=self.company_id, branch=self.branch_id)

    @api.onchange('workcenter_id')
    def onchange_workcenter_id(self):
        if self.workcenter_id:
            self.location_id = self.workcenter_id.location_id.id
            self.finished_location_id = self.workcenter_id.location_finished_id.id
            self.byproduct_location_id = self.workcenter_id.location_byproduct_id.id

    @api.onchange('fixed_length', 'fixed_width', 'fixed_height')
    def onchange_fixed_fields(self):
        for line in self.line_ids:

            # fixed_fields in line will change after save
            # need to change immediately for editable column purposes
            for field in MEASURES:
                key = 'fixed_' + field
                line[key] = self[key]

            line.update_measures()
            line.update_volume()
            line.update_product_qty()

    @api.onchange('line_ids', 'product_id')
    def onchange_line_ids(self):
        line_ids = self.line_ids
        lot_ids = line_ids.mapped('lot_id')

        leftover_values = [(5,)]
        for lot_id in lot_ids:
            old_volume = lot_id.volume
            
            lot_line_ids = line_ids.filtered(lambda l: l.lot_id == lot_id)
            new_volume = sum(lot_line_ids.mapped('total_volume'))
            volume = old_volume - new_volume

            leftover_values.append((0, 0, {
                'cutting_leftover_id': self.id,
                'lot_id': lot_id.id,
                'volume': volume,
            }))

        self.leftover_ids = leftover_values
        for leftover in self.leftover_ids:
            leftover.onchange_volume()

    def button_confirm(self):
        for record in self:
            matrix_is_on = record.is_matrix_on
            state = record.state
            if (matrix_is_on and state != 'approved') or (not matrix_is_on and state != 'draft'):
                continue
            record.state = 'confirm'

    def button_start(self):
        for record in self:
            if record.state != 'confirm':
                continue
            record.date_start = fields.Datetime.now()
            record.state = 'progress'

            if record.cutting_plan_id:
                record.cutting_plan_id.state = 'progress'

    def button_done(self):
        for record in self:

            if record.state in ('done', 'cancel'):
                continue

            if record.state != 'progress':
                raise UserError(_('Cannot done cutting order that is not in progress state!'))

            if not record.line_ids:
                raise UserError(_('Please fill cut product tab first!'))

            if any(line.volume < 0.0 for line in record.leftover_ids):
                raise UserError(_('Left over volume can not less than 0!'))

            lot_ids = record.lot_ids
            line_ids = record.line_ids
            leftover_ids = record.leftover_ids

            location_id = record.location_id
            location_dest_id = record.finished_location_id
            production_location_id = record.product_id.with_company(record.company_id).property_stock_production

            for leftover_id in leftover_ids:
                leftover_lot_ids = lot_ids.filtered(lambda l: l.lot_id == leftover_id.lot_id)
                leftover_lot_ids.write({'lot_leftover_id': leftover_id.id})
                leftover_line_ids = line_ids.filtered(lambda l: l.lot_id == leftover_id.lot_id)
                leftover_line_ids.write({'line_leftover_id': leftover_id.id})

            for lot_id in lot_ids:
                # reverse original move
                lot_id._cut(location_id, production_location_id)

                # create cut move
                lot_line_ids = line_ids.filtered(lambda l: l.lot_id == lot_id.lot_id)
                lot_line_ids._cut(production_location_id, location_dest_id)

                # create leftover move
                leftover_id = lot_id.lot_leftover_id
                leftover_id._cut(production_location_id, location_id)

                # update original lot measures
                new_measures = dict([(m, leftover_id[m]) for m in MEASURES])
                lot_id.lot_id.write(new_measures)

            record.write({
                'state': 'done',
                'date_finished': fields.Datetime.now()
            })

    def button_cancel(self):
        for record in self:
            if record.state not in ('confirm', 'progress', 'done'):
                continue
            record.state = 'cancel'

    def action_approval(self):
        is_whatsapp_notify = self.env['ir.config_parameter'].sudo().get_param('equip3_manuf_cutting.send_whatsapp_notif_co')
        for record in self:
            if not record.is_matrix_on:
                continue
            options = {
                'post_log': True,
                'send_system': True,
                'send_email': True,
                'send_whatsapp': is_whatsapp_notify
            }
            record.approval_matrix_id.action_approval(record, options=options)
            record.write({'state': 'to_be_approved'})

    def action_approve(self):
        for record in self:
            if not record.is_matrix_on:
                continue
            record.approval_matrix_id.action_approve(record)
            if all(l.state == 'approved' for l in record.approval_matrix_line_ids):
                record.write({'state': 'approved'})

    def action_reject(self, reason=False):
        for record in self:
            if not record.is_matrix_on:
                continue
            result = record.approval_matrix_id.action_reject(record, reason=reason)
            if result is not True:
                return result
            if any(l.state == 'rejected' for l in record.approval_matrix_line_ids):
                record.write({'state': 'rejected'})

    def button_recut(self):
        self.ensure_one()
        lines = []
        for line in self.line_ids:
            for lot in line.name_ids:
                if lot:
                    exist_lot = self.env['stock.production.lot'].search([('name', '=', lot.name)])
                    stock_id = False
                    if not exist_lot:
                        stock_id = self.env['stock.production.lot'].create({
                            'name': lot.name,
                            'product_id': line.product_id.id,
                            'cutting_line_id': line.id,
                        })
                    else:
                        stock_id = exist_lot

                    cutting_line = self.env['cutting.order.line'].create({
                        'lot_id': stock_id.id,
                        'product_qty': line.product_qty,
                        'product_uom_id': line.product_uom_id.id,
                        'length': line.length,
                        'cutting_uom_id': line.cutting_uom_id.id,
                        'width': line.width,
                        'cutting_uom_id': line.cutting_uom_id.id,
                        'height': line.height,
                        'cutting_uom_id': line.cutting_uom_id.id,
                        'volume': line.volume,
                    })
                    if cutting_line:
                        for cutting in cutting_line:
                            if cutting:
                                line_vals = {
                                    'lot_id': stock_id.id,
                                    'product_qty': cutting.product_qty,
                                    'product_uom_id': cutting.product_uom_id.id,
                                    'length': cutting.length,
                                    'cutting_uom_id': cutting.cutting_uom_id.id,
                                    'width': cutting.width,
                                    'cutting_uom_id': cutting.cutting_uom_id.id,
                                    'height': cutting.height,
                                    'cutting_uom_id': cutting.cutting_uom_id.id,
                                    'volume': cutting.volume,
                                }
                                lines.append((0, 0, line_vals))
        return {
            'type': 'ir.actions.act_window',
            'name': _("Recut"),
            'res_model': 'cutting.order',
            'view_mode': 'form',
            'target': 'new',
            'context': {
                'create': False,
                'edit': False,
                'default_location_id': self.location_id.id,
                'default_product_id': self.product_id.id,
                'default_workcenter_id': self.workcenter_id.id,
                'default_date_planned_start': self.date_planned_start,
                'default_date_start': self.date_start,
                'default_analytic_group_ids': self.analytic_group_ids.ids,
                'default_fixed_length': False,
                'default_fixed_width': False,
                'default_fixed_height': False,
                'default_cutting_order': True,
                'default_company_id': self.company_id.id,
                'default_branch_id': self.branch_id.id,
                'default_create_date': self.create_date,
                'default_create_uid': self.create_uid.id,
                'default_approval_matrix_id': self.approval_matrix_id.id,
                'default_lot_ids': lines,
                'default_finished_location_id': self.finished_location_id.id,
                'default_byproduct_location_id': self.byproduct_location_id.id,
                'default_source_document': self.name,
            },
        }


class CuttingOrderByproduct(models.Model):
    _name = 'cutting.order.byproduct'
    _description = 'Cutting Order Byproduct'

    cutting_id = fields.Many2one('cutting.order', string='Cutting', required=True, ondelete='cascade')
    product_id = fields.Many2one('product.product', string='Product', required=True)
    product_qty = fields.Float(string='Quantity', digits='Product Unit of Measure', default=1.0)
    product_uom_id = fields.Many2one(string='Unit of Measure', related='product_id.uom_id')
    allocation_cost = fields.Float(string='Allocation Cost (%)', digits='Product Unit of Measure', required=True)
