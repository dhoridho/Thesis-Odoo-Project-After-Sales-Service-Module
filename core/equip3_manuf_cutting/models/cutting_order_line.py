from odoo import models, fields, api, _
from odoo.exceptions import ValidationError

MEASURES = ['length', 'width', 'height']


class CuttingOrderLine(models.Model):
    _name = 'cutting.order.line'
    _description = 'Cutting Order Line'

    @api.depends('lot_id', 'lot_id.name', 'cutting_lot_id', 'cutting_line_id', 'cutting_leftover_id')
    def _compute_name(self):
        for record in self:
            name = ''
            if record.cutting_lot_id:
                name = 'ORIGINAL '
            elif record.cutting_line_id:
                name = 'CUT '
            elif record.cutting_leftover_id:
                name = 'LEFTOVER '
            record.name = '%s%s' % (name, record.lot_id.name)

    @api.depends('cutting_lot_id', 'cutting_line_id', 'cutting_leftover_id')
    def _compute_cutting_id(self):
        cutting = self.env['cutting.order']
        for record in self:
            record.cutting_id = record.cutting_lot_id or record.cutting_line_id or record.cutting_leftover_id or cutting

    @api.depends('cut_qty', 'lot_id', 'lot_ids', 'cutting_line_id',
                 'cutting_line_id.line_ids', 'cutting_line_id.product_id')
    def _compute_lot_names(self):
        CuttingLot = self.env['cutting.order.line.name']
        Lot = self.env['stock.production.lot']

        for record in self:
            if not record.cutting_line_id or not record.lot_id:
                record.name_ids = [(6, 0, [])]
                continue

            name_ids = self.env['cutting.order.line.name']

            if record.lot_ids:
                for lot in record.lot_ids:
                    name_ids |= CuttingLot.create({'line_id': record.id, 'name': lot.name})
                record.name_ids = [(6, 0, name_ids.ids)]
                continue

            loop = int(record.cut_qty)
            lot_id = record.lot_id
            line_ids = record.cutting_line_id.line_ids
            product_id = record.cutting_line_id.product_id
            is_autogenerated = record.is_autogenerated

            sequences = line_ids.filtered(lambda l: l != record).name_ids.mapped('name')
            next_sequence = product_id.product_tmpl_id._get_next_lot_and_serial

            number = 1
            if is_autogenerated:
                if product_id.tracking == 'serial':
                    number = int(product_id.current_sequence)
                else:
                    number = int(product_id.in_current_sequence)

            for line_id in line_ids:
                if line_id == record:
                    break
                line_id._compute_name()
                if record.lot_id == line_id.lot_id:
                    number += int(line_id.cut_qty)

            for i in range(loop):
                while True:
                    if is_autogenerated:
                        sequence = next_sequence(current_sequence=number + i)
                    else:
                        sequence = lot_id.name + '/' + str(number + i).zfill(3)

                    exist = Lot.search([('name', '=', sequence)])
                    if not exist and sequence not in sequences:
                        break
                    number += 1

                name_ids |= CuttingLot.create({'line_id': record.id, 'name': sequence})
                sequences.append(sequence)

            record.name_ids = [(6, 0, name_ids.ids)]

    @api.depends('cutting_id', 'cutting_lot_id', 'cutting_line_id', 'cutting_leftover_id',
                 'cutting_id.lot_ids', 'cutting_id.lot_ids.lot_id', 'cutting_id.line_ids')
    def _compute_allowed_lots(self):
        for record in self:
            allowed_ids = []
            if record.cutting_lot_id:
                added_lot_ids = record.cutting_id.lot_ids.mapped('lot_id').ids
                allowed_ids = list(set(record.cutting_id.allowed_lot_ids.ids) - set(added_lot_ids))
            elif record.cutting_line_id:
                allowed_ids = record.cutting_id.lot_ids.mapped('lot_id').ids
            elif record.cutting_leftover_id:
                allowed_ids = record.cutting_id.line_ids.mapped('lot_id').ids
            record.allowed_lot_ids = [(6, 0, allowed_ids)]

    name = fields.Char(compute=_compute_name)

    cutting_id = fields.Many2one('cutting.order', string='Cutting Order', compute=_compute_cutting_id, store=True)
    cutting_lot_id = fields.Many2one('cutting.order', string='Cutting Order Lot')
    cutting_line_id = fields.Many2one('cutting.order', string='Cutting Order Line')
    cutting_leftover_id = fields.Many2one('cutting.order', string='Cutting Order Leftover')

    allowed_lot_ids = fields.Many2many('stock.production.lot', compute=_compute_allowed_lots)
    lot_id = fields.Many2one(
        'stock.production.lot', string='Lot/Serial Number', required=True, domain="[('id', 'in', allowed_lot_ids)]")
    lot_ids = fields.One2many(
        'stock.production.lot', 'cutting_line_id', string='Final Lot/Serial Number', readonly=True)
    move_ids = fields.One2many('stock.move', 'cutting_line_id', string='Finished Moves', readonly=True)

    product_qty = fields.Float(string='Quantity', digits='Product Unit of Measure', default=1.0)
    cut_qty = fields.Integer(string='Quantity To Cut', default=1.0)
    length = fields.Float(string='Length', digits='Product Unit of Measure', default=1.0)
    width = fields.Float(string='Width', digits='Product Unit of Measure', default=1.0)
    height = fields.Float(string='Height', digits='Product Unit of Measure', default=1.0)
    volume = fields.Float(string='Volume', digits='Product Unit of Measure', default=1.0)
    total_volume = fields.Float(string='Total Volume', digits='Product Unit of Measure', default=1.0)

    # cutting.order fields
    company_id = fields.Many2one(related='cutting_id.company_id')
    product_id = fields.Many2one(related='cutting_id.product_id')
    product_uom_id = fields.Many2one(string='Product UoM', related='cutting_id.product_uom_id')
    cutting_uom_id = fields.Many2one(string='Cutting UoM', related='cutting_id.cutting_uom_id')
    fixed_length = fields.Boolean(related='cutting_id.fixed_length')
    fixed_width = fields.Boolean(related='cutting_id.fixed_width')
    fixed_height = fields.Boolean(related='cutting_id.fixed_height')
    is_autogenerated = fields.Boolean(related='cutting_id.is_autogenerated')
    state = fields.Selection(related='cutting_id.state')

    # technical fields
    lot_leftover_id = fields.Many2one('cutting.order.line', string='Lot Leftover')
    line_leftover_id = fields.Many2one('cutting.order.line', string='Line Leftover')
    line_ids = fields.One2many('cutting.order.line', 'line_leftover_id', string='Cutting Lines')
    name_ids = fields.One2many(
        'cutting.order.line.name', 'line_id', string='Lot/Serial Name', compute=_compute_lot_names)

    def _cut(self, location_id, location_dest_id):

        if len(set(self.mapped('lot_id'))) != 1:
            raise ValidationError(_('Cannot cut lines with different lots!'))

        for record in self:
            if record.cutting_line_id:
                lot_ids = record._create_lots()
            else:
                record.lot_id.write({'original_lot_id': record.lot_id.id})
                lot_ids = [record.lot_id]

            lot = record.lot_id
            qty = record.product_qty

            for lot_id in lot_ids:

                # do not create move for leftover that has volume == 0.0
                if record.cutting_leftover_id and record.volume == 0.0:
                    continue

                # create stock.move
                move = record._create_stock_move(location_id, location_dest_id, qty, lot_id)
                move._action_done()

                if record.product_id.tracking != 'serial':
                    continue
                
                svl_ids = move.stock_valuation_layer_ids
                sign = not record.cutting_lot_id and 1.0 or -1.0
                svl_value = sum(svl_ids.mapped('value'))
                if lot.is_cutted:
                    svl_value = lot.last_cutting_value * sign
                this_volume = record.volume
                lot_volume = record.get_volume(length=lot.length, width=lot.width, height=lot.height)
                value = (this_volume * svl_value) / lot_volume

                if record.cutting_leftover_id:
                    lot.write({'is_cutted': True, 'last_cutting_value': value})
                elif record.cutting_line_id:
                    lot_id.write({'is_cutted': True, 'last_cutting_value': value})

                svl_ids.write({'unit_cost': value, 'value': value })
    
    def _update_lot_sequence(self):
        self.ensure_one()
        if self.is_autogenerated:
            if self.product_id.tracking == 'serial':
                field = 'current_sequence'
                digits = self.product_id.digits
            else:
                field = 'in_current_sequence'
                digits = self.product_id.in_digits
            self.product_id.write({field: str(int(self.product_id[field]) + 1).zfill(digits)})

    def _create_lots(self):
        self.ensure_one()
        if not self.cutting_line_id:
            return
        lot_values = dict([(m, self[m]) for m in MEASURES])
        lot_values.update({
            'product_id': self.product_id.id,
            'company_id': self.company_id.id,
            'cutting_line_id': self.id,
            'original_lot_id': self.lot_id.id,
        })

        lot_ids = self.env['stock.production.lot']
        for lot_name in self.name_ids:
            values = lot_values.copy()
            values.update({'name': lot_name.name})
            lot_ids |= self.env['stock.production.lot'].create(values)
        self._update_lot_sequence()
        return lot_ids

    def _create_stock_move(self, location_id, location_dest_id, quantity, lot_id):
        self.ensure_one()
        tracking = self.product_id.tracking
        move_values = {
            'name': self.cutting_id.name,
            'location_id': location_id.id,
            'location_dest_id': location_dest_id.id,
            'product_id': self.product_id.id,
            'product_uom': self.product_id.uom_id.id,
            'product_uom_qty': quantity,
            'company_id': self.company_id.id,
            'cutting_line_id': self.id
        }

        move = self.env['stock.move'].create(move_values)
        loop = tracking == 'serial' and int(quantity) or 1
        qty_done = tracking == 'serial' and 1 or quantity

        move_line_values = []
        for i in range(loop):
            to_update = {'qty_done': qty_done, 'lot_id': lot_id.id}
            if tracking == 'serial':
                to_update['product_uom_id'] = self.product_id.uom_id.id
            values = move._prepare_move_line_vals()
            values.update(to_update)
            move_line_values.append((0, 0, values))

        move.move_line_ids = move_line_values
        return move

    def get_volume(self, **kwargs):
        volume = 1.0
        is_all_zero = True
        for field in MEASURES:
            value = kwargs.get(field, self[field])
            if value > 0.0:
                volume *= value
                is_all_zero = False
        return is_all_zero and 0.0 or volume

    def update_product_qty(self):
        lot_id = self.lot_id
        if self.cutting_lot_id:
            self.product_qty = lot_id.product_qty
        else:
            if self.product_id.tracking == 'lot':
                lot_volume = self.get_volume(length=lot_id.length, width=lot_id.width, height=lot_id.height)
                if lot_volume > 0.0:
                    self.product_qty = (self.volume / lot_volume) * lot_id.product_qty
            else:
                self.product_qty = 1.0

    def update_measures(self):
        lot_id = self.lot_id
        if self.cutting_lot_id or self.cutting_line_id:
            for field in MEASURES:
                if not lot_id:
                    self[field] = 1.0
                else:
                    if self['fixed_' + field] or self.cutting_lot_id:
                        self[field] = lot_id[field]
                    elif not self['fixed_' + field] and self.cutting_line_id:
                        self[field] = 1.0
        else:
            cutting_id = self.cutting_id
            for field in MEASURES:
                if cutting_id['fixed_' + field]:
                    if self.volume <= 0.0:
                        value = 0.0
                    else:
                        value = lot_id[field]
                else:
                    line_ids = cutting_id.line_ids.filtered(lambda l: l.lot_id == lot_id)
                    line_field = 0.0
                    for line_id in line_ids:
                        line_field += line_id.cut_qty * line_id[field]
                    value = lot_id[field] - line_field
                self[field] = value > 0.0 and value or 0.0

    def update_volume(self):
        if self.cutting_lot_id or self.cutting_line_id:
            self.volume = self.get_volume()
            if self.cutting_line_id:
                self.total_volume = self.volume * self.cut_qty

    @api.onchange('lot_id')
    def onchange_lot_id(self):
        if self.cutting_lot_id or self.cutting_line_id:
            self.update_measures()
            self.update_volume()
            self.update_product_qty()

    @api.onchange('cut_qty')
    def onchange_cut_qty(self):
        if self.cutting_line_id:
            self.update_product_qty()
            self.update_volume()

    @api.onchange('volume')
    def onchange_volume(self):
        if self.cutting_leftover_id:
            self.update_product_qty()
            self.update_measures()

    @api.onchange('length', 'width', 'height')
    def onchange_measures(self):
        if self.cutting_line_id:
            self.update_volume()
            self.update_product_qty()


class CuttingOrderLineName(models.Model):
    _name = 'cutting.order.line.name'
    _description = 'Cutting Order Line Name'

    line_id = fields.Many2one('cutting.order.line', string='Cutting Line')
    name = fields.Char(required=True)
