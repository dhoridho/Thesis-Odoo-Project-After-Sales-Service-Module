# -*- coding: utf-8 -*-

from odoo import _, _lt, api, fields, models
from odoo.osv.expression import AND
from odoo.exceptions import UserError

import logging
_logger = logging.getLogger(__name__)

SEARCH_PANEL_ERROR_MESSAGE = _lt("Too many items to display.")

SEARCH_PANEL_LIMIT = 1000


# todo: 使用猴子补丁，不影响后续继承
class Base(models.AbstractModel):
    _inherit = 'base'

    def _get_superbar_supported_types(self):
        return ['many2one', 'many2many', 'char', 'integer', 'float', 'monetary', 'selection', 'boolean', 'date', 'datetime']

    @api.model
    # 增加action中原有 domain 的 叠加，原生中本函数是没有 domain 的
    # 直接重写方法先
    def search_panel_select_range(self, field_name, **kwargs):
        """
        Return possible values of the field field_name (case select="one"),
        possibly with counters, and the parent field (if any and required)
        used to hierarchize them.

        :param field_name: the name of a field;
            of type many2one or selection.
        :param category_domain: domain generated by categories. Default is [].
        :param comodel_domain: domain of field values (if relational). Default is [].
        :param enable_counters: whether to count records by value. Default is False.
        :param expand: whether to return the full range of field values in comodel_domain
                        or only the field image values (possibly filtered and/or completed
                        with parents if hierarchize is set). Default is False.
        :param filter_domain: domain generated by filters. Default is [].
        :param hierarchize: determines if the categories must be displayed hierarchically
                            (if possible). If set to true and _parent_name is set on the
                            comodel field, the information necessary for the hierarchization will
                            be returned. Default is True.
        :param limit: integer, maximal number of values to fetch. Default is None.
        :param search_domain: base domain of search. Default is [].
                        with parents if hierarchize is set)
        :return: {
            'parent_field': parent field on the comodel of field, or False
            'values': array of dictionaries containing some info on the records
                        available on the comodel of the field 'field_name'.
                        The display name, the __count (how many records with that value)
                        and possibly parent_field are fetched.
        }
        or an object with an error message when limit is defined and is reached.
        """
    # todo: 参考原生 search_panel_select_multi_range， 在panel中过滤不要用 domain 字段，用category_domain，
    # todo: 要将 model_domain 传递出来， 参考 web 模块中 def search_panel_select_multi_range
    # 注意，此处 category_domain，是传用户点击 search_panel 中传来的过滤
    #  !! 在odoo14中，search_panel中基本不需要再过滤，其会根据当前搜索的主结果自动过滤。
    #     导致的问题是 lazy模式没要重新处理了。
        field = self._fields[field_name]
        supported_types = self._get_superbar_supported_types()
        if field.type not in supported_types:
            types = dict(self.env["ir.model.fields"]._fields["ttype"]._description_selection(self.env))
            raise UserError(_(
                'Only types %(supported_types)s are supported for category (found type %(field_type)s)',
                supported_types=", ".join(types[t] for t in supported_types),
                field_type=types[field.type],
            ))

        model_domain = kwargs.get('search_domain', [])
        extra_domain = AND([
            kwargs.get('category_domain', []),
            kwargs.get('filter_domain', []),
        ])

        if field.type == 'selection':
            return {
                'parent_field': False,
                'values': self._search_panel_selection_range(field_name, model_domain=model_domain,
                                extra_domain=extra_domain, **kwargs
                            ),
            }

        Comodel = self.env[field.comodel_name].with_context(hierarchical_naming=False)

        # 显示在列表中的主字段 name_field 定义，默认用 name
        display_field = kwargs.get('name_field', 'name')
        if not hasattr(self, display_field):
            display_field = 'display_name'
        field_names = ['display_name']
        if display_field != 'display_name':
            field_names = ['display_name', display_field]

        hierarchize = kwargs.get('hierarchize', True)
        parent_name = False
        if hierarchize and Comodel._parent_name in Comodel._fields:
            parent_name = Comodel._parent_name
            field_names.append(parent_name)

            def get_parent_id(record):
                value = record[parent_name]
                return value and value[0]
        else:
            hierarchize = False

        comodel_domain = kwargs.get('comodel_domain', [])
        enable_counters = kwargs.get('enable_counters')
        expand = kwargs.get('expand')
        limit = kwargs.get('limit')

        if enable_counters or not expand:
            domain_image = self._search_panel_field_image(field_name,
                model_domain=model_domain, extra_domain=extra_domain,
                only_counters=expand,
                set_limit=limit and not (expand or hierarchize or comodel_domain), **kwargs
            )

        if not (expand or hierarchize or comodel_domain):
            values = list(domain_image.values())
            if limit and len(values) == limit:
                return {'error_msg': str(SEARCH_PANEL_ERROR_MESSAGE)}
            return {
                'parent_field': parent_name,
                'values': values,
            }

        # 以下对 comodel_records 的处理实现了对左bar的过滤
        if not expand:
            image_element_ids = list(domain_image.keys())
            if hierarchize:
                condition = [('id', 'parent_of', image_element_ids)]
            else:
                condition = [('id', 'in', image_element_ids)]
            comodel_domain = AND([comodel_domain, condition])
        comodel_records = Comodel.search_read(comodel_domain, field_names, limit=limit)

        if hierarchize:
            ids = [rec['id'] for rec in comodel_records] if expand else image_element_ids
            comodel_records = self._search_panel_sanitized_parent_hierarchy(comodel_records, parent_name, ids)

        if limit and len(comodel_records) == limit:
            return {'error_msg': str(SEARCH_PANEL_ERROR_MESSAGE)}

        field_range = {}
        for record in comodel_records:
            record_id = record['id']
            values = {
                'id': record_id,
                'display_name': record[display_field],
            }
            # todo: 后续加 title
            # if display_field != 'display_name':
            #     values.update({display_field: record[display_field]})
            if hierarchize:
                values[parent_name] = get_parent_id(record)
            if enable_counters:
                image_element = domain_image.get(record_id)
                values['__count'] = image_element['__count'] if image_element else 0
            field_range[record_id] = values

        if hierarchize and enable_counters:
            self._search_panel_global_counters(field_range, parent_name)

        return {
            'parent_field': parent_name,
            'values': list(field_range.values()),
        }

# models.AbstractModel.search_panel_select_range = Base.app_search_panel_select_range